# Kodkvalitetskrav

## Namngivning

| Namn & beskrivning | Reflektion och regler från Clean Code |
| ------------------ | ------------------------------------- |
| **TextAnalyzer** (Namn på huvudklassen med publika metoder) | **Use intention-revealing names:** TextAnalyzer är ett namn med stora ambitioner på en klass som innehåller metoder för en väldigt grundläggande analys av ord och tecken i en text. Namnet hade kunnat vara mer precist och bättre ringat in att det rör sig om en kvantitativ analys och inte en kvalitativ för att bättre beskriva "why it exists, what it does and how it's used". |
| **findUniqueWords(numberOfWords)** (Namn på publik metod som används för att hitta alla unika ord. Orden returneras i en array.) | **Use intention-revealing names:** Eftersom funktionsdeklarationer i JavaScript inte visar vad som returneras, har intention-revealing Names-principen gett mig en del huvudbry. Metoden findUniqueWords hittar förvisso alla unika ord, men returnerar dem också. Att orden returneras är inte nödvändigtvis underförstått, eftersom en metod lika väl kan alternera ett objekts state som att returnera ett värde. Borde findUniqueWords heta findAndReturnUniqueWords för att kompensera för att JavaScript inte är objektorienterat? Borde den heta getUniqueWords, eller är det en typ av desinformation som påminner för mycket om hur getters deklareras? |
| **countAverageWordLength** / **findMedianWordLength** (Namn på två publika metoder som används för att hitta/räkna ut den genomsnittliga ordlängden respektive median-ordlängden. Längden returneras som ett nummer (type number).) | **Pick one word per concept:** I mina metoder använder jag orden "count" och "find" på ett inte helt konsekvent sätt. Tydligast blir det här, där både metoderna kan sägas antingen hitta eller beräkna en viss ordlängd. Jag använder också count för att räkna antal. countAverageWordLength borde kanske heta compute, eller "find" för att följa det mönster som finns i övriga metodnamn. |
| **numberOfWords** (Namn på argument, används i flera olika metoder (findMostCommonWords, findLongestWord, findShortestWord)) | **Make meaningful distinctions:** Ordet *of* är ett noise-word som egentligen inte tillför något. Kanske borde vara wordCount istället? Bara "words" funkar inte, eftersom "words" inte avslöjar att argumentet måste vara ett nummer. Frågan är om wordCount blir för visuellt likt countWords och ändå missar att skapa meningsfull distinktion? |
| **countChars** (Namn på publik metod som används för att hitta/räkna antal tecken) | **Avoid Mental Mapping:** Orddelen "char" i countChars är inte riktigt ord utan en förkortning, som måste översättas av den som läser koden till "Character". Hela ordet borde skrivas ut och det bör åtgärdas i nästa version av koden. **Avoid disinformation:** Orddelen "char" är, vid sidan av en förkortning, också ett keyword för en särskild datatyp i flera språk. Eftersom det inte är typen char som avses, borde or namnet ändras till countCharacters. |

### Reflektion kring kapitel 2.
Spontana tankar som dyker upp, är att kvaliteten på koden i stor utsträckning beror på erfarenhetsnivån hos den som skriver. Att lära sig en uppsättning regler räcker inte, särskilt inte när kodbasen växer. Vissa regler – som *don't be cute* – kanske är lika självklara för en junior och en senior programmerare, medan *don't pun* kräver att man har full koll på koncept och keywords för att namnge på ett koherent sätt. Att undvika desinformation i avseendet att undvika ord som har en särskilt mening i programmeringsmiljö, kräver också en viss nivå av kunskap för att bli meningsfull. Den är också kontextuell, eftersom den får olika betydelse beroende på kunskapsnivån hos den som skriver, läser och hanterar koden. Det som är enkelt definierat och avgränsat i teorin, är kanske inte alltid lika självklart och enkelt att upprätthålla i praktiken?

---

## Funktioner

| Metodnamn och länk eller kod |  antal rader (ex. ws) | Reflektion |
| ---------------------------- | --------------------- | ---------- |
| findMostCommonWordLength() | 21 | **Small!:** För att vara den längsta funktionen är den väldigt nära gränsen på 20 rader som sätts i Clean Code för maxstorlek. **Do one thing:** Förutom att hitta den vanligast förekommande ordlängden, testar också funktionen om argumentet är ett nummer. Detta test sker i flera funktioner i klassen och hade kunnat brytas ut och bli en egen funktion med ett argument (monadic). Funktionen räknar också alla ordlängder. Detta borde göras i en separat funktion. **Function arguments:** Funktionen är monadic och hade kunnat göras niladic, men då till bekostnad på flexibiliteten. Kanske hade den kunnat returnera alla ordlängder i ordning, och sedan låtit funktionen som anropar findMostCommonWordLength hantera nästa steg. |
| findMedianWordLength() | 18 | **Function arguments:** funktionen är niladic, vilket är att föredra och bidrar till att undvika onödig komplexitet. **Do one thing:** gör funktionen en eller två saker? Funktionen gör, eventuellt, det den säger att den gör: hittar median-ordlängden. Men ett steg är att den först hittar alla ordlängder – är detta en separat procedur? För tydlighetens skull, skulle den delen av funktionen kunna brytas ut till en egen funktion. **Small!** Funktionen är inte stor, även om den med lite refaktorering hade kunnat vara mindre. En stor portion av kodlängden beror på att medianen beräknas olika beroende på om antalet ord är jämnt eller ojämnt – något som ligger i begreppets natur och är svårt att undvika. Funktionens *Indentation level* är också max en, vilket är ok. |
| #countWordFrequency() | 18 | **One level of abstraction:** koden berättar en tydlig historia och håller sig till en "computing" abstraktionsnivå. **DRY:** delar av koden upprepas på ett nästan identiskt sätt i metoden #countCharFrequency, som finns i en annan klass. Hade det gått att omstrukturera för att lösa det, eller är det kanske ok eftersom koden till stor del består av for- och if-satser på en låg abstraktionsnivå? **Do one thing:** farligt nära den övre gränsen för nivå av indrag (två) men klarar sig precis. Och den gör också en sak, vilket är det namnet säger att den gör. |
| #countCharFrequency() | 18 | *Även samma reflektioner som på raden ovan.* **Have no side effects:** funktionen anropar en annan funktion (#splitIntoChars), som inte returnerar ett värde utan adderar alla tecken till en privat medlem av klassen. Detta är en sidoeffekt av #countCharFrequency, och logiken bör lösas på ett annat sätt. Båda metoderna är dock privata, och kan inte anropas "okontrollerat" när som helst. |
| findLongestWord(numberOfWords) | 14 | **Do one thing:** förutom att hitta det längsta ordet, så kontrolleras också numberOfWords. Detta bör hanteras separat. **Use descriptive names:** Namnet borde också ändras till findLongestWords, eftersom funktionen kan returnera fler än ett ord. (Se även reflektioner kring vad som returneras och namngivning i sektionen ovan som rör namngivning av funktioner i större detalj). |

### Reflektion kring kapitel 3.
Detta resonerar med mig och svarar på många funderingar jag har haft kring hur man hanterar komplexiteten i en stor kodbas. Att hålla funktionerna minimala, undvika argument i möjligast mån, låta varje funktion göra en sak och unvika sidoeffekter är saker som jag spontant har försökt från början, men nu förstår bättre (och förhoppningsvis kommer att bli ännu bättre på). Med JavaScript blir detta så klart mer utmanande än i ett objektorienterat språk och kräver större noggrannhet. Abstraktionsnivå tycker jag är lite svårt att greppa och behöver sätta mig in i mer. Även om den faktiska funktionen hos en funktion är på låg abstraktionsnivå så är det lätt hänt att själva konceptet för samma funktion blir på en högre nivå, vilket kanske är ett semantiskt problem eftersom det beror på namngivningen?

---

## Reflektion
I det stora hela tycker jag att min kodkvalitet är god och uppfyller många av reglerna kring namngivning (substantiv för klasser och verb för metoder, don’t be cute, use intention-revealing names) och funktioner (small!, use desciptive names, function arguments), även om det hade kunnat bli ännu bättre. Att använda namn som beskriver precis vad en funktion gör, varken mer eller mindre, tycker jag är konceptuellt klurigt i JavaScript, eftersom funktionsdeklarationen inte avslöjar om funktionen returnerar något och i så fall vad. Bör detta då adderas till funktionsnamnet? Borde ”findMostCommonWords” alltså bli ”findAndReturnMostCommonWords”, eller borde findMostCommonWords istället alternera ett objekt, som kan hämtas via en getter? 

En reflektion jag gjorde vid kodanalys utifrån kodkvalitetskrav, är att jag har trott att mina funktioner gör en sak, när de i realiteten ofta gör flera. Jag hade kunnat omstrukturera minst en vända till och bryta ut delar ur många funktioner och skapa nya funktioner av dem, exempelvis för kontroll av funktionsargument. Detta hade också gjort min kod mer DRY.

Flera av mina metoder ha sidoeffekter, om än (tyvärr?) avsiktliga. Detta är något jag verkligen behöver se över. I en liten modul fungerar det, men i en större kodbas kommer det att vara omöjligt att överblicka och kontrollera. En funderingar jag har, är om (och i så fall hur) man anropar privata metoder direkt vid instansiering av en klass. Är det ok att göra detta i konstruktorn? Jag gör det också i den privata funktionen #setStringToAnalyze, eftersom strängen behöver definieras innan funktionerna anropas. Det blir då en kedja av funktioner som anropas vid instansiering. Bäddar detta för framtida fel?

Att välja ett ord per koncept känns logiskt, men svårt att kontrollera. Spontant har jag ingen aning om jag har gjort detta eller inte. Ibland tycker jag också att det är svårt att avgöra gränserna för ett koncept. Är *count* och *find* samma sak i countAverageWordLength
och findMostCommonWordLength? Och borde *count* egentligen kallas *compute*?

I det stora hela tycker jag att min kod är välstrukturerad, men att kodkvaliteten kan bli mycket bättre om jag följer reglerna i kapitel 2 och 3 i Clean Code.